//
//  NewsfeedPresenter.swift
//  VkNewsFeed
//
//  Created by Иван Абрамов on 02.09.2020.
//  Copyright (c) 2020 Иван Абрамов. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol NewsfeedPresentationLogic {
  func presentData(response: Model.Response.ResponseType)
}

class NewsfeedPresenter: NewsfeedPresentationLogic {
    weak var viewController: NewsfeedDisplayLogic?
    
    let cellLayoutCalculator : FeedCellLayoutCalculatorProtocol = NewsFeedCellLayoutCalculator()
    
    let dateFormatter : DateFormatter = {
        let dateFormatter = DateFormatter()
        dateFormatter.locale = Locale(identifier: "ru_RU")
        dateFormatter.dateFormat = "d MMM 'в' HH:mm"
        
        return dateFormatter
    }()
    
//  MARK: Present Data
  
    func presentData(response: Model.Response.ResponseType) {
        switch response {
            case .presentNewsFeed(let feed, let postIds):
                let cells = feed.items.map { (item) in
                    return cellViewModel(from: item, profiles: feed.profiles, groups: feed.groups, postIds: postIds)
                }
                
                let footerTitle = String.localizedStringWithFormat(NSLocalizedString("newsfeed cells count", comment: ""), cells.count)
                let feedViewModel = FeedViewModel.init(cells: cells, footerTitle: footerTitle)
                viewController?.displayModel(viewModel: .displayNewsFeed(model: feedViewModel))
        case .presentUser(user: let user):
            viewController?.displayModel(viewModel: .displayUser(model: UserViewModel(photoURL: user.photo100,
                                                                                      screenName: user.screenName)))
        case .displayFooterView:
            viewController?.displayModel(viewModel: .displayFooterView)
        }
    }
    
    private func cellViewModel(from item: FeedItem, profiles: [Profile], groups: [Group],  postIds: [Int]) -> FeedViewModel.Cell {
        
        let profile = self.profile(for: item.sourceId, profiles: profiles, groups: groups)
        let photoAttachements = self.photoAttachements(feedItem: item)
        let linkAttachment = self.linkAttachment(feedItem: item)
        
        let date = Date(timeIntervalSince1970: item.date)
        let dateTitle = dateFormatter.string(from: date)
        
        let isCellFullSize =  postIds.contains(item.postId)
        
        let sizes = cellLayoutCalculator.size(postText: item.text, photoAttachements: photoAttachements, linkAttachment: linkAttachment, isCellFullSize: isCellFullSize)
        
        return FeedViewModel.Cell.init(
            postId: item.postId,
            iconUrlString: profile.photo,
            name: profile.name,
            date: dateTitle,
            text: item.text,
            likes: formatCount(item.likes?.count),
            comments: formatCount(item.comments?.count),
            shares: formatCount(item.reposts?.count),
            views: formatCount(item.views?.count),
            photoAttachements: photoAttachements,
            linkAttachment: linkAttachment,
            sizes: sizes)
    }
    
    private func profile(for sourceId: Int, profiles: [Profile], groups: [Group]) -> ProfileRepresentable {
        
        let sourceArr : [ProfileRepresentable] = sourceId >= 0 ? profiles : groups
        
        let profile = sourceArr.first {  (profileRepresentable) -> Bool in
            profileRepresentable.id == abs(sourceId)
        }
        
        return profile!
      
    }
    
    private func photoAttachements(feedItem: FeedItem) ->  [FeedViewModel.FeedCellPhotoAttachement]  {
        guard let photos = feedItem.attachments?.compactMap( {
            $0.photo
        }) else {
            return []
        }
        
        return photos.compactMap { (photo)  in
            FeedViewModel.FeedCellPhotoAttachement(photoURLString: photo.url,
            width: photo.width,
            height: photo.height)
        }
    }
    
    private func linkAttachment(feedItem: FeedItem) ->  FeedViewModel.FeedCellLinkAttachement?  {
        guard let links = feedItem.attachments?.compactMap( {
            $0.link
        }), let firstLink = links.first else {
            return nil
        }
        
        return FeedViewModel.FeedCellLinkAttachement(photoURLString: firstLink.photo?.sizes.first?.url,
                                                     linkTitle: firstLink.title,
                                                     url: firstLink.url)
    }
    
    private func formatCount(_ count: Int?) -> String {
        guard let count = count else  { return "" }
        
        var countString = String(count)
        
        if 4...6 ~= countString.count {
            countString = countString.dropLast(3) + "K"
        }
        
        if countString.count > 6 {
            countString = countString.dropLast(6) + "M"
        }
        
        return countString
    }
}
